%!TEX root = ../../main.tex
\newcommand{\body}{\ensuremath{\t{body}}\xspace}
\newcommand{\strokewidth}{\ensuremath{\t{stroke\_w}}\xspace}
\newcommand{\segmentationpoints}{\ensuremath{\t{sps}}\xspace}
\newcommand{\segmentationpoint}{\ensuremath{\t{sp}}\xspace}
\newcommand{\image}{\ensuremath{\t{image}}\xspace}
\newcommand{\subimage}{\ensuremath{\t{sub\_image}}\xspace}
\newcommand{\leftsubimage}{\ensuremath{\t{left}}\xspace}
\newcommand{\rightsubimage}{\ensuremath{\t{right}}\xspace}
\newcommand{\segmentfurther}{\ensuremath{\t{todo}}\xspace}
\newcommand{\characters}{\ensuremath{\t{done}}\xspace}
\newcommand{\parameters}{\ensuremath{\t{parameters}}\xspace}

\begin{figure}
	\input{shared/method/segmentation_algorithm}
	\caption{The Binary Over Segmentation Algorithm.}
	\label{alg:method:segmentation:algorithm}
\end{figure}

We use a form of binary over segmentation to recognize characters in the word, see \cref{alg:method:segmentation:algorithm}. This algorithm aims to segment an image on the most likely segmentation point. If these sub images are not characters they can be selected again for further segmentation. This segmenting of sub images is repeated until the termination condition has been reached. The final list of characters is the list of characters, \characters, merged with the list of images that could be segmented further, \segmentfurther. This merge also ensures that the order of the images is correct.

The \parameters passed to \function{segment}{} in \cref{alg:method:segmentation:algorithm} contain the maximum word length and the minimum, mean and maximum image width, height and number of foreground pixels. Other than maximum word length, these parameters are computed based on the train data, by collecting these data from each character image, the minimum, mean and maximum are computed over all measurements that fall within two standard deviations of the mean. The maximum word length is simply the length of the longest word in the train data.

The different functions used in \cref{alg:method:segmentation:algorithm} are discussed in \crefrange{sss:method:segmentaton:bodyregion}{sss:method:segmentaton:termination}.

\subsubsection{Body Region}
\label{sss:method:segmentaton:bodyregion}
	The body region is the part of the image between the lower and upper base line. The lower base line is computed as the mode of the minimum row index with a foreground pixel in each column. The upper baseline is computed similarly, but uses the maximum row index.

	Using the body region for the computation of the segmentation points reduces the influence of extensive ligatures \cite{lee2012binary}. \Cref{fig:method:segmentation:baseline} presents some examples of computed baselines. The first example, \Cref{fig:method:segmentation:baseline:succes}, reflects the intended outcome. The second example, \cref{fig:method:segmentation:baseline:failure}, draws the upper baseline too high, probably due too the extra curve on the last letter.

	\begin{figure}
		\centering
		\subfloat[]{
			\includegraphics[height=7em]{shared/img/method/base_line_succes.png}%
			\label{fig:method:segmentation:baseline:succes}%
		}
		\hspace{0.05\columnwidth}
		\subfloat[]{
			\includegraphics[height=7em]{shared/img/method/base_line_fail.png}%
			\label{fig:method:segmentation:baseline:failure}%
		}
		\caption{An example of \protect\subref{fig:method:segmentation:baseline:succes} correct and \protect\subref{fig:method:segmentation:baseline:failure} incorrect found baselines. The computed baselines are shown in red. If the found baselines were incorrect, the expected baselines are shown in blue.}
		\label{fig:method:segmentation:baseline}
	\end{figure}

\subsubsection{Stroke Width}
\label{sss:method:segmentaton:strokwidth}
	The stroke width refers to how thick the stroke of a pen is. It is computed as the mode of the number of sequential foreground pixels in one row or column of pixels. As different pens or authors can write on the same page it is more robust to compute the stroke width per word image instead of per page image.

\subsubsection{Segmentation Points}
\label{sss:method:segmentaton:segmentationpoints}
	To find the segmentation lines we first determine the suspicious regions. A suspicious region is a region in the body of the word image where the vertical pixel density is greater than some threshold, we have set this threshold to $2 \cdot \strokewidth$, \cref{fig:method:segmentation:suspiciousRegions} illustrates the suspicious regions found in a word. 

	\begin{figure}
		\timemachine{Create this image based on our dataset ourselves.}
		\centering
		\includegraphics[width=\columnwidth]{shared/img/method/suspicious_regions.png}
		\caption{The vertical pixel density of the body of the image above the word image.  The threshold for suspicious regions is shown as a line in the histogram. The shaded areas show the suspicious regions. For the regions shaded in a color the lines associated with the segmentations points are drawn. The image is adapted from \cite{lee2012binary}.}
		\label{fig:method:segmentation:suspiciousRegions}
	\end{figure}

	Based on these regions the initial set of segmentation points is determined. If the width of a region is smaller than the minimum character width, the region results in one segmentation line in the middle of the regions, this case is illustrated by the blue region in \cref{fig:method:segmentation:suspiciousRegions}. In regions with a width that is equal to or greater than the minimum character width, the red region in \cref{fig:method:segmentation:suspiciousRegions}, segmentation points are placed at the end of the region and on intervals of the minimum character width that start at the beginning of the region. Before starting the segmentation these lines are filtered to ensure optimal placement. 

	Firstly all segmentation lines over a hole in the image are removed. This filtering is restricted to Latin alphabet, which as a number of letters with. It also assumes that it  does not occur that two letters are connected via a whole, although noise that was not removed could cause the occurrence of a hole between two letters. Holes are detected via region growing algorithm. 

	After all segmentation lines crossing a hole have been removed we move some of the segmentation lines in such a way that in the final image the distance between two segmentation lines is always greater than the minimum character width. This is done as follows: iterate over all pairs of lines that are present when you move from left to right through the image. If the distance between the lines that make up the pair is smaller than the the minimum character width remove the lines, and place a new line in the middle between those two lines. This process is then recursively repeated for the segmentation lines to the left of the new line and for the lines to the right of this line. 

	\timemachine{Show with an image.}

	The resulting set of segmentation points is used for the actual segmentation. 

\subsubsection{Select Sub-Image}
\label{sss:method:segmentaton:selectsubimage}
	As shown in \cref{alg:method:segmentation:algorithm} the algorithm keeps track of two lists, one with character images, \characters, and one with images that need to be segmented further, \segmentfurther. At the start of each iteration an image is selected for further segmentation for the second list. From this list the image with the highest width over height ratio is selected. This is done on the assumption that the widest image is the most likely to contain multiple characters. It should be noted that the height of the images is not the same for all images, as white borders are from \leftsubimage and \rightsubimage before they are stored in the either \characters or \segmentfurther. This reduces the influence of sloppy word bounding boxes on the segmentation.

\subsubsection{Select Segmentation Point}
\label{sss:method:segmentaton:selectssp}
	Given an image for further segmentation with multiple segmentation lines one needs to select along which segmentation line the image should be split. This is done based on two scores: the distance score and the vertical pixel density score. 

	The first promotes the selection of a segmentation line near the center of the image. This should avoid the chain failure problems. Let the $x$-coordinates of the segmentation line and the center of the image be represented by $l_x$ and $c_x$, respectively, the distance score is then defined as
		\begin{equation}\label{eq:method:segmenation:selectSP:distancecriterion}
			s_{\text{distance}} = \frac{\abs{c_x - l_x}}{c_x}.
		\end{equation}

	The second scores promotes the selection of segmentation points that indicate spaces where white space separates two characters. Let the height of the sub image be $w$ and $l_d$ the pixel density in the image underneath the line, the density score is then:
		\begin{equation}
			s_{\text{density}} = \frac{l_d}{w}.
		\end{equation}
	Both scores are summed, the line with the lowest score is selected as the segmentation point.

\subsubsection{Split}
\label{sss:method:segmentaton:splitimage}

	\begin{figure}
		\timemachine{Indicate $g$ and $s$ in the image.}
		\centering
		\subfloat[]{
			\includegraphics[width=6em, height=4em, keepaspectratio=True]{shared/img/method/split_straight_path.png}%
			\raisebox{1em}{\hspace{2em} $\to$ \hspace{2em}}
			\includegraphics[width=6em, height=4em, keepaspectratio=True]{shared/img/method/split_straight_left.png}%
			\raisebox{1em}{\hspace{2em} $\&$ \hspace{2em}}
			\includegraphics[width=6em, height=4em, keepaspectratio=True]{shared/img/method/split_straigt_right.png}%
			\label{fig:method:segmentation:splitting:straight}%
		}

		\subfloat[]{
			\includegraphics[width=6em, height=4em, keepaspectratio=True]{shared/img/method/split_astar_path.png}%
			\raisebox{1em}{\hspace{2em} $\to$ \hspace{2em}}
			\includegraphics[width=6em, height=4em, keepaspectratio=True]{shared/img/method/split_astar_left.png}%
			\raisebox{1em}{\hspace{2em} $\&$ \hspace{2em}}
			\includegraphics[width=6em, height=4em, keepaspectratio=True]{shared/img/method/split_astar_right.png}%
			\label{fig:method:segmentation:splitting:astar}%
		}
		\caption{Splitting based on a segmentation point, shown as a blue line, along \protect\subref{fig:method:segmentation:splitting:straight} a straight path and \protect\subref{fig:method:segmentation:splitting:astar} a path found with \astar. The used paths are shown in red. The original image is shown on the left of the arrow, the resulting sub images are shown on the right side of the arrow.}
		\label{fig:method:segmentation:splitting:comparison}
	\end{figure}

	The simplest way to split the image along the segmentation line, $l$, is to designate all pixel to the left of the line to \leftsubimage, and all pixels to the right of the line to \rightsubimage. However this can result in artifacts as illustrated in \cref{fig:method:segmentation:splitting:straight}, where part of the `n' is added to the `i', resulting in a letter that looks more like a `c' than an `i' in \leftsubimage.

	In \cref{fig:method:segmentation:splitting:astar} the image are split along a path that keeps both characters intact. This path is found by looking for a path from $s$ to $g$, the pixels on the segmentation line on the first and last row, respectively. From some pixel only its four-connected neighbors can be reached. The path is searched in an area with width minimum character width centered on the segmentation line, to restrict the path and computation time. The heuristic distance from pixel $n$ to the goal pixel, $g$:
	\begin{equation}\label{eq:method:segmentation:heuristic}
		h(n) = \abs{g_x - n_x} + \abs{g_y - n_y}.
	\end{equation}
	We chose the Manhattan distance as that best represents possible paths taken when walking along pixels in an image.

	The cost of getting from the start pixel, $s$, to pixel $n$ is defined as:
	\begin{equation}\label{eq:method:segmentation:costFunction}
		g(n) = 
		\begin{cases}
			g(n') + 1	& \text{if } n \text{ is a background pixel.}\\
			g(n') + i 	& \text{if } n \text{ is a foreground pixel on $l$.}\\
			\infty 		& \text{otherwise.}
		\end{cases}
	\end{equation}
	where $i$ is the intersection penalty and $n'$ is the four connected neighbor from which we reached $n$.

	\Cref{eq:method:segmentation:costFunction} allows the path along which the characters are separated to only intersect foreground pixels on the segmentation line. Furthermore the intersection penalty ensures that the characters are only split along a winding path if a straight path is not possible. We have set the intersection penalty, $i$, to 5. If there are no foreground pixels underneath the segmentation line, the distance function reduces to the Minkowski distance with $p = 1$. 

\subsubsection{Detecting a Character Image}
\label{sss:method:segmentaton:segmentfurther}
	Essential to assign a sub image to the correct path is determining if it is an image of a character or if it should be segmented further. This determination is made based on three properties of the sub image: the width, the height and the number of foreground pixels. 

	The sub image should satisfy two conditions to be considered a character: The width of the sub image should be between between the minimum and maximum image width. And the number of foreground pixels should be greater than the minimum number of foreground pixels.

	An image is considered for further segmentation if it satisfies three conditions: it should have segmentation lines, the number of foreground pixels and the image width should be greater than twice the minimum number of foreground pixels and the minimum image width, respectively. 

	If neither of the preceding sets of conditions are satisfied the image is considered for further segmentation if its width is greater than the mean character width and it has segmentation lines. If its width is less than two standard deviations away from the mean character width it is added to \characters, otherwise it is discarded.

\subsubsection{Continue}
\label{sss:method:segmentaton:termination}
	Segmentation is continued as long as the following conditions are satisfied: we have not yet found more characters than the length of the longest word in the lexicon and there are still images in the list \segmentfurther. The first condition aims to reduce over segmentation.